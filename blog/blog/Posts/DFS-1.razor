@page "/dfs-1"
<MudText Typo="Typo.h4">Пишем генератор лабиринтов по алгоритму DFS на C#</MudText>
<MudText Typo="Typo.h6">&emsp;23 января, 2019</MudText>
<MudDivider/>
<MudText Class="pt-6 pb-6">
    &emsp;Блуждая по интернету в поисках идей для практики в изучении языка,
    наткнулся на такую вещь, как алгоритмы построения лабиринтов.
    В голове сразу возникла мысль написать генератор лабиринтов в качестве упражнения.
    В гугле по данной теме оказалось очень много материала, как на русском, так и на английском,
    но чтобы не рассеивать внимание на множестве всяких интересных примеров,
    я выбрал в качестве ориентира один <MudLink Href="https://habr.com/ru/post/262345/">источник</MudLink>.
    В этой статье алгоритм носит название “алгоритм Эллера”, в других же источниках может
    называться “deep-first-search” или “spanning tree”.
</MudText>
<MudText>
    1. Сделайте начальную клетку текущей и отметьте ее как посещенную.
</MudText>
<MudText>
    2. Пока есть непосещенные клетки
</MudText>
<MudText>
    &emsp;2.1 Если текущая клетка имеет непосещенных «соседей»
</MudText>
<MudText>
    &emsp;&emsp;2.1.1 Выберите случайную клетку из соседних
</MudText>
<MudText>
    &emsp;&emsp;2.1.2 Уберите стенку между текущей клеткой и выбранной
</MudText>
<MudText>
    &emsp;&emsp;2.1.3 Сделайте выбранную клетку текущей и отметьте ее как посещенную.
</MudText>
<MudText>
    &emsp;2.2 Иначе если стек не пуст
</MudText>
<MudText>
    &emsp;&emsp;2.2.1Выдерните клетку из стека.
</MudText>
<MudText Class="pt-6 pb-6">
    &emsp;Построенный по такому алгоритму лабиринт будет являться “идеальным лабиринтом”.
    Т.е. в нем не будет изолированных областей и из любой его точки можно дойти до любой другой.
</MudText>

<MudText Typo="Typo.h6">&emsp;Реализация алгоритма</MudText> 

<MudText Class="pt-4 pb-4">
    &emsp;Во-первых, нам понадобится определить тип,
    который будет хранить в себе координаты текущей ячейки,
    её тип (стена/клетка) и состояние (посещена/не посещена).
</MudText> 
<MudPaper Class="ma-4" Elevation="10">
        <MudText Class="pa-4" Typo="Typo.overline">Структура ячейки</MudText>
    <MudText Class="pa-4">
        <pre>
public struct Cell
{
  public int X { get; set; }
  public int Y { get; set; }
  public bool _isCell { get; set; }
  public bool _isVisited { get; set; }
  public Cell(int x, int y, bool isVisited = false, bool isCell = true)
  {
      X = x;
      Y = y;
      _isCell = isCell;
      _isVisited = isVisited;
  }
}
            </pre>
    </MudText>
</MudPaper>


<MudText>
    &emsp;По умолчанию, ячейка будет инициализироваться непосещенной клеткой.
    Далее определим класс для создания объекта лабиринта.
</MudText> 
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Класс лабиринта</MudText>
    <MudText Class="pa-4">
        <pre>
class Maze
{
    public readonly Cell[,] _cells;
    private int _width;
    private int _height;
    public Stack&lt;Cell&gt; _path = new Stack&lt;Cell&gt;();
    public List&lt;Cell&gt; _neighbours = new List&lt;Cell&gt;();
    public Random rnd = new Random();
    public Cell start;
    public Cell finish;

    public Maze(int width, int height)
    {
        start = new Cell(1, 1, true, true);
        finish = new Cell(width - 3, height - 3, true, true);
        _width = width;
        _height = height;
        _cells = new Cell[width, height];
        for (var i = 0; i &lt; width; i++)
        for (var j = 0; j &lt; height; j++)
        //если ячейка нечетная по х и по у и не выходит за пределы лабиринта
        if ((i % 2 != 0 &amp;&amp; j % 2 != 0) &amp;&amp; (i &lt; _width - 1 &amp;&amp; j &lt; _height - 1)) 
        {
            _cells[i, j] = new Cell(i, j); //то это клетка (по умолчанию)
        }
        else
        {
            _cells[i, j] = new Cell(i, j, false, false);
        }

        _path.Push(start);
        _cells[start.X, start.Y] = start;
    }
}
            </pre>
    </MudText>
</MudPaper>

<MudText>
     &emsp;Хранить всю матрицу ячеек вместе с их состояниями будем в массиве
    <b>_cells</b>. Путь, который мы будем прокладывать от начальной точки в стеке
    <b>_path</b>, список соседей клетки в листе <b>_neighbours</b>. Инициализацию
    объекта рандома тоже надо вынести из цикла, во избежание генерации
    “одинаковых случайных чисел”. Клетки <b>start</b> и <b>finish</b> можно задать любыми,
    но я буду определять их как левый верхний и правый нижний углы.
</MudText>
<MudText>
    &emsp;Для реализации алгоритма сперва необходимо построить сетку элементов,
    где каждая “клетка” будет окружена “стенами”. Например вот так.
</MudText>
<MudImage Src="https://habrastorage.org/files/ed2/eb4/b56/ed2eb4b5618b46e085279c1c11e380f9.png"></MudImage>
<MudText>
Теперь осталось проложить путь через эту сетку.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Функция создания лабиринта</MudText>
    <MudText Class="pa-4">
        <pre>
public void CreateMaze()
{
    _cells[start.X, start.Y] = start;

    while (_path.Count != 0) //пока в стеке есть клетки ищем соседей и строим путь
    {
        _neighbours.Clear();
        GetNeighbours(_path.Peek());

        if (_neighbours.Count != 0)
        {
            Cell nextCell = ChooseNeighbour(_neighbours);
            RemoveWall(_path.Peek(), nextCell);
            nextCell._isVisited = true; //делаем текущую клетку посещенной
            _cells[nextCell.X, nextCell.Y]._isVisited = true; //и в общем массиве
            _path.Push(nextCell); //затем добавляем её в стек
        }
        else
        {
        _path.Pop();
        }
    }
}
            </pre>
    </MudText>
</MudPaper>

<MudText>&emsp;И несколько вспомогательных функций:</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Поиск соседей</MudText>
    <MudText Class="pa-4">
        <pre>
private void GetNeighbours(Cell localcell) // Получаем соседа текущей клетки
{
    int x = localcell.X;
    int y = localcell.Y;
    const int distance = 2;
    Cell[] possibleNeighbours = new[] // Список всех возможных соседeй
    {
        new Cell(x, y - distance), // Up
        new Cell(x + distance, y), // Right
        new Cell(x, y + distance), // Down
        new Cell(x - distance, y) // Left
    };

    for (int i = 0; i &lt; 4; i++) // Проверяем все 4 направления
    {
        Cell curNeighbour = possibleNeighbours[i];
        if (curNeighbour.X > 0 &amp;&amp; curNeighbour.X &lt; _width 
            &amp;&amp; curNeighbour.Y > 0 &amp;&amp; curNeighbour.Y &lt; _height)
        {// Если сосед не выходит за стенки лабиринта
            if (_cells[curNeighbour.X, curNeighbour.Y]._isCell 
                &amp;&amp; !_cells[curNeighbour.X, curNeighbour.Y]._isVisited)
            { // А также является клеткой и непосещен
                _neighbours.Add(curNeighbour);
            }// добавляем соседа в Лист соседей
        }
    }
}
            </pre>
    </MudText>
</MudPaper>

<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Выбор случайного соседа</MudText>
    <MudText Class="pa-4">
        <pre>
private Cell ChooseNeighbour(List&lt;Cell&gt; neighbours) //выбор случайного соседа
{
    int r = rnd.Next(neighbours.Count);
    return neighbours[r];
}
            </pre>
    </MudText>
</MudPaper>

<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Удаление стены</MudText>
    <MudText Class="pa-4">
        <pre>
private void RemoveWall(Cell first, Cell second)
{
    int xDiff = second.X - first.X;
    int yDiff = second.Y - first.Y;
    
    // Узнаем направление удаления стены
    int addX = (xDiff != 0) ? xDiff / Math.Abs(xDiff) : 0; 
    int addY = (yDiff != 0) ? yDiff / Math.Abs(yDiff) : 0;
    // Координаты удаленной стены
    _cells[first.X + addX, first.Y + addY]._isCell = true; //обращаем стену в клетку
    _cells[first.X + addX, first.Y + addY]._isVisited = true; //и делаем ее посещенной
    second._isVisited = true; //делаем клетку посещенной
    _cells[second.X, second.Y] = second;
}
            </pre>
    </MudText>
</MudPaper>
<MudText>
    &emsp;Пример выполнения алгоритма:
</MudText>
<MudImage Fluid="true" Src="https://lh3.googleusercontent.com/Ay75GBvNgWbJheFMMS8b-A0VZO4gZcomC-O3qB1jbmT4YAlp0ddy_GU72RI8QHLozuTCt1OcVsSTSCgdrZziI5e4oCmpm2x6Y8lUORbH8MHIUWvmpNDbe7zdOpDvW8Sxm6rLfbZ9"></MudImage>

<MudText>
    &emsp;Теперь оно работает, но большие лабиринты таким образом не сгенерировать, 
  так как окно консоли имеет ограниченный максимальный размер.
  Поэтому нужно либо писать лабиринт во внешний файл, либо выводить куда-то кроме консоли.
</MudText>
<MudText Typo="Typo.h6">
    &emsp;Реализация графики
</MudText>

<MudText>
    &emsp;Для реализации графики я решил сделать простенькую форму на WinForms и добавить туда отрисовку массива.
    Добавим несколько полей на форму.
</MudText>

<MudImage Src="https://lh5.googleusercontent.com/5FA_r2hsOA3EBz16C8S_DSN3be86Ws7UNTWfMJFr8QBzGIrGiWxgeT1R-eJpYTp-cLUvHQ_IvLKsCZm6V58db0afsMcwd0ud_enCxI0ke6voCJ6cwcUvKlP9tSEobZmU38wonWuB"></MudImage>
<MudText>
    &emsp;Ввод размеров, кнопка для генерации и ничего лишнего. Далее я наткнулся в одном 
    из репозиториев на мысль, о которой сам сразу не подумал. Лабиринт нужно как-то вписывать
    в имеющееся свободное пространство на форме. При этом он не должен зажиматься в уголок формы, е
    сли имеет маленькую размерность и не должен выходить за её пределы, если имеет большую размерность.
    С этой задачей отлично справится автомасштабирование на основе размера окна.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Код формы</MudText>
    <MudText Class="pa-4">
        <pre>
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();
    }

    private int Xmin, Ymin, CellWid, CellHgt;
    private void button1_Click(object sender, EventArgs e)
    {
        int wid = int.Parse(txtWidth.Text);
        int hgt = int.Parse(txtHeight.Text);
        //вычисляем ширину одной ячейки, чтобы автомасштабировать полученную картинку
        CellWid = picMaze.ClientSize.Width / (wid + 2);
        CellHgt = picMaze.ClientSize.Height / (hgt + 2);

        if (CellWid > CellHgt) CellWid = CellHgt;
        else CellHgt = CellWid;

        Xmin = (picMaze.ClientSize.Width - wid * CellWid) / 2;
        Ymin = (picMaze.ClientSize.Height - hgt * CellHgt) / 2;
    }
}
            </pre>
    </MudText>
</MudPaper>
<MudText>
    &emsp;И добавим сюда функцию для отрисовки ячеек.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
        <MudText Class="pa-4" Typo="Typo.overline">Рисование лабиринта</MudText>
    <MudText Class="pa-4">
        <pre>
void DrawMaze()
{
    Bitmap bm = new Bitmap(picMaze.ClientSize.Width,picMaze.ClientSize.Height);
    Brush whiteBrush = new SolidBrush(Color.White);
    Brush blackBrush = new SolidBrush(Color.Black);

    using (Graphics gr = Graphics.FromImage(bm))
    {
        gr.SmoothingMode = SmoothingMode.AntiAlias;
        for (var i = 0; i &lt; maze._cells.GetUpperBound(0); i++)
            for (var j = 0; j &lt; maze._cells.GetUpperBound(1); j++)
            {
                Point point = new Point(i*CellWid, j*CellWid);
                Size size = new Size(CellWid, CellWid);
                Rectangle rec = new Rectangle(point, size);

                if (maze._cells[i, j]._isCell)
                {
                    gr.FillRectangle(whiteBrush, rec);
                }
                else
                {
                    gr.FillRectangle(blackBrush, rec);
                }
            }
        gr.FillRectangle(new SolidBrush(Color.Green), //заливаем старт зеленым
        new Rectangle(new Point(maze.start.X * CellWid, maze.start.Y * CellWid),
        new Size(CellWid, CellWid)));
        gr.FillRectangle(new SolidBrush(Color.Red), //а финиш красным
        new Rectangle(new Point(maze.finish.X * CellWid, maze.finish.Y * CellWid),
        new Size(CellWid, CellWid)));
    }
    picMaze.Image = bm; //отображаем картинку
}
            </pre>
    </MudText>
</MudPaper>
<MudText>
    &emsp;Вуаля! Можно проверять, что получилось.
</MudText>

<MudImage Src="https://lh4.googleusercontent.com/iRLvbKK22ZmODgkTKQK_pzVpXEf9FV9iJfCioIBgrYOeT7yk11CsqeTMyM1vWPZgzkNClobLDYNtlNiCo0JSWNOjem_srwkSLu63lN77zPLmd_26_fifp8KqYKxmF9iEKz6hV7jL"></MudImage>
<MudImage Fluid="true" Src="https://lh3.googleusercontent.com/WZUTdhH5gyLGRbgrG-44SKU7450mUcROMG8_V4s5dxHFQf9psY08uJzXulbo_u3nQsVcEG7fAhW-gGN92kZe2UEuO5RZFplUnYC9xMEF_tfyhbxcc0N618GNieGRv-C58dzppvi1"></MudImage>


<MudText>
    &emsp;Что же, оно работает, но не без недостатков)<br/>
    - При вводе нечетной размерности, одна из стенок “съедается”.<br/>
    - При построении огромных лабиринтов нет возможности сохранить их в хорошем качестве.<br/>
    В следующий раз будет написание программы прохождения лабиринта, а также фикс этих проблем.
    <MudLink Href="https://github.com/ShockThunder/mazeGenerator_dfs">Ссылка</MudLink> на репозиторий.
    Вторая <MudLink Href="/dfs-2">часть</MudLink>.
</MudText>


@code {

}