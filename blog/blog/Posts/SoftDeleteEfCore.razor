@page "/soft-delete-ef-core"
<MudText Typo="Typo.h4">Мягкое удаление в EF Core</MudText>
<MudText Typo="Typo.h6">&emsp;27 октября, 2020</MudText>
<MudDivider/>
<MudText Class="pt-6 pb-6">
    Мягкое удаление в EF Core реализуется довольно просто.
    Достаточно создать интерфейс ISoftDelete, например, и реализовать его у всех мягкоудаляемых сущностей.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">Функция отрисовки решения</MudText>
    <MudText Class="pa-4">
        <pre>
public interface ISoftDelete
{
    bool IsDeleted { get; set; }
}
            </pre>
    </MudText>
</MudPaper>
<MudText Class="pt-6 pb-6">
    Затем необходимо переопределить метод OnSaveChanges, чтобы сущности, помеченные для удаления не удалялись, а просто меняли своё свойство.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">OnSaveChanges</MudText>
    <MudText Class="pa-4">
        <pre>
public override int SaveChanges(bool acceptAllChangesOnSuccess)
{
    ProcessEntities();
    return base.SaveChanges(acceptAllChangesOnSuccess);
}

public override async Task&lt;int&gt; SaveChangesAsync(bool acceptAllChangesOnSuccess,
            CancellationToken cancellationToken = new CancellationToken())
{
    await ProcessEntitiesAsync();

    return await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
}
            </pre>
    </MudText>
</MudPaper>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">ProcessEntities</MudText>
    <MudText Class="pa-4">
        <pre>
private async Task ProcessEntitiesAsync()
{
    var entries = ChangeTracker.Entries().ToList();

    foreach (var entry in entries)
    {
        if (entry.Entity is ISoftDelete)
            await HandleSoftDeleteEntryAsync(entry);
    }
}
            </pre>
    </MudText>
</MudPaper>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">HandleSoftDelete</MudText>
    <MudText Class="pa-4">
        <pre>
private async Task HandleSoftDeleteEntryAsync(EntityEntry entry)
{
    switch (entry.State)
    {
        case EntityState.Deleted:
            SoftDeleteEntry(entry);
            break;
        case EntityState.Added:
            await entry.ReloadAsync();
            ((ISoftDelete) entry.Entity).IsDeleted = false;
            break;
    }
}
            </pre>
    </MudText>
</MudPaper>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">SoftDeleteEntry</MudText>
    <MudText Class="pa-4">
        <pre>
private void SoftDeleteEntry(EntityEntry entry)
{
    entry.State = EntityState.Modified;
    ((ISoftDelete) entry.Entity).IsDeleted = true;
}
            </pre>
    </MudText>
</MudPaper>

<MudText Class="pt-6 pb-6">
    Вот здесь поджидает первый сюрприз. В EF Core нет каскадного мягкого удаления, 
    впрочем нет и обычного. У этого issue скоро будет 5 лет с открытия. https://github.com/dotnet/efcore/issues/4025
    Для обработки зависимых сущностей нужно пройтись вручную по зависимым и “удалить их”.
</MudText>

<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">HandleDependent</MudText>
    <MudText Class="pa-4">
        <pre>
private void HandleDependent(EntityEntry entry)
{
    foreach (var navigationEntry in entry.Navigations.Where(n =>
                !n.Metadata.IsDependentToPrincipal() && n.CurrentValue != null))
    {
        if (navigationEntry.CurrentValue == null)
            continue;

        if (navigationEntry is CollectionEntry collectionEntry)
        {
            foreach (var dependentEntry in collectionEntry.CurrentValue)
            {
                SoftDeleteEntry(Entry(dependentEntry));
            }
        }
        else
        {
            var dependentEntry = navigationEntry.CurrentValue;
            SoftDeleteEntry(Entry(dependentEntry));
        }
    }
}
            </pre>
    </MudText>
</MudPaper>
<MudText Class="pt-6 pb-6">
    И офк, это нужно добавить в обработку мягкоудаляемых сущностей.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">HandleSoftDeleteEntryAsync</MudText>
    <MudText Class="pa-4">
        <pre>
private void HandleDependent(EntityEntry entry)
{
    foreach (var navigationEntry in entry.Navigations.Where(n =>
                !n.Metadata.IsDependentToPrincipal() && n.CurrentValue != null))
        {
            if (navigationEntry.CurrentValue == null)
                continue;

            if (navigationEntry is CollectionEntry collectionEntry)
            {
                foreach (var dependentEntry in collectionEntry.CurrentValue)
                {
                    SoftDeleteEntry(Entry(dependentEntry));
                }
            }
            else
            {
                var dependentEntry = navigationEntry.CurrentValue;
                SoftDeleteEntry(Entry(dependentEntry));
            }
       }
}
            </pre>
    </MudText>
</MudPaper>
<MudText Class="pt-6">
    Далее, чтобы у программистов работа с ORM не изменилась,
    нужно добавить фильтр, который бы не пускал в контекст “удаленные” объекты.
</MudText>
<MudText>
    Тут поджидает второй сюрприз. Если мы просто укажем тип сущности для modelBuilder,
</MudText>

<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4">
        <pre>
modelBuilder.Entity&lt;ISoftDelete&gt;().HasQueryFilter(x => x.IsDeleted == false);
            </pre>
    </MudText>
</MudPaper>

<MudText Class="pt-6 pb-6">
    то поймаем runtime exception
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4">
        <pre>
ArgumentException: The specified type 'YOURAPP.YOURMODELS.ISoftDelete'must
 be a non-interface reference type to be used as an entity type
            </pre>
    </MudText>
</MudPaper>
<MudText Class="pt-6 pb-6">
    Поэтому типы будем получать в рантайме.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">OnModelCreating</MudText>
    <MudText Class="pa-4">
        <pre>
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    var softDeleteEntries = modelBuilder.Model
        .GetEntityTypes()
        .Where(x => typeof(ISoftDelete).IsAssignableFrom(x.ClrType));

    foreach (var mutableEntityType in softDeleteEntries)
    {
        var entityTypeBuilder = modelBuilder.Entity(mutableEntityType.ClrType);

        entityTypeBuilder.HasQueryFilter(
            ConvertFilterExpression&lt;ISoftDelete&gt;(e 
                => !e.IsDeleted, mutableEntityType.ClrType));
    }
    base.OnModelCreating(modelBuilder);
}
            </pre>
    </MudText>
</MudPaper>
<MudText Class="pt-6 pb-6">
    А чтобы работать с ClrType в modelBuilder нужно передать экспрешн. Для этого добавим конвертер.
</MudText>
<MudPaper Class="ma-4" Elevation="10">
    <MudText Class="pa-4" Typo="Typo.overline">ConvertFilterExpression</MudText>
    <MudText Class="pa-4">
        <pre>
 private static LambdaExpression ConvertFilterExpression&lt;TInterface&gt;(
            Expression&lt;Func&lt;TInterface, bool&gt;&gt; filterExpression,
            Type entityType)
{
    var newParam = Expression.Parameter(entityType);
    var newBody = ReplacingExpressionVisitor
                    .Replace(filterExpression.Parameters.Single(),
                            newParam,
                            filterExpression.Body);

    return Expression.Lambda(newBody, newParam);
}
            </pre>
    </MudText>
</MudPaper>

<MudText Class="pt-6 pb-6">
    Это все основные моменты.
    Ссылки на источники:
</MudText>
<MudText Class="pt-6 pb-6">
    <MudLink Href="https://stackoverflow.com/questions/47673524/ef-core-soft-delete-with-shadow-properties-and-query-filters">Ковертер для экспрешна.</MudLink>
</MudText>
<MudText Class="pt-6 pb-6">
    Более <MudLink Href="https://www.thereformedprogrammer.net/ef-core-in-depth-soft-deleting-data-with-global-query-filters/">свежая версия</MudLink>
 мягкого удаления от автора EF Core in action (выглядит рабочей. В книге 2018 года приведен куцый и не рабочий пример)
</MudText>
<MudText Class="pt-6 pb-6">
    <MudLink Href="https://stackoverflow.com/questions/49242151/how-to-make-soft-delete-in-cascade-with-entity-framework-core-including-navigati">Каскадное</MudLink> мягкое удаление <br/>
    <MudLink Href="https://github.com/dotnet/efcore/issues/4025">Ишью</MudLink> на мягкое удаление
</MudText>


